<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GenreWise Analysis</title>
    <style>
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <svg>

    </svg>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>

        const margin = { top: 40, right: 50, bottom: 50, left: 70 }; // Define margin
        const width = 800;
        const height = 600;

        // Create SVG container
        const svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        function getPercentage(value) {
            const percentage_index = value.indexOf('%');
            const percentage = parseFloat(value.substring(percentage_index - 2, percentage_index));
            return percentage;
        }

        function getcolor(value) {
            if (value < 10) {
                return "black";
            } else if (value >= 10 && value < 20) {
                return "grey";
            } else if (value >= 20 && value < 30) {
                return "blue";
            } else if (value >= 30 && value < 40) {
                return "cyan";
            } else if (value >= 40 && value < 50) {
                return "green";
            } else if (value >= 50 && value < 60) {
                return "yellow";
            } else if (value >= 60 && value < 70) {
                return "orange";
            } else if (value >= 70 && value < 80) {
                return "orangeRed";
            } else if (value >= 80 && value < 90) {
                return "red";
            } else {
                return "darkRed"; // Max value nearing red
            }
        }


        function createPlot(data_object) {
            const myGroups = ['Action', 'RPG', 'Strategy', 'Indie', 'Casual'];
            const myVars = data_object.nameList;

            // Define the color scale for the heatmap
            const colorScale = d3.scaleSequential()
                .interpolator(d3.interpolateViridis) // You can use any color scale you prefer
                .domain([0, 100]); // Set the domain of the color scale based on xList values

            // Create the heatmap
            const yScale = d3.scaleBand()
                .domain(myGroups)
                .range([margin.top, height - margin.bottom])
                .paddingInner(0.1);
            const xScale = d3.scaleBand()
                .domain(myVars)
                .range([margin.left, width - margin.right])
                .paddingInner(0.1);

            svg.selectAll(".heatmap-square")
                .data(data_object.xList)
                .enter()
                .append("rect")
                .attr("class", "heatmap-square")
                .attr("x", (d, i) => xScale(myVars[i])) // Adjust x position for squares
                .attr("y", (d, i) => yScale(data_object.yList[i])) // Adjust y position for squares
                .attr("width", xScale.bandwidth()) // Set width of squares
                .attr("height", yScale.bandwidth()) // Set height of squares
                .style("fill", (d, i) => {
                    return getcolor(getPercentage(data_object.xList[i]))
                    // console.log(getPercentage(data_object.xList[i]))
                })
                .on("mouseover", function (event, d, i) {
                    const name = data_object.nameList[i];
                    const group = data_object.yList[i];
                    const tooltipText = `Name: ${name}, Group: ${group}`;
                    d3.select(this).attr("fill", "orange"); // Change color on mouseover
                    d3.select(this).append("title").text(tooltipText); // Add tooltip
                })
                .on("mouseout", function () {
                    d3.select(this).attr("fill", (d, i) => colorScale(data_object.xList[i])); // Revert color
                    d3.select(this).select("title").remove(); // Remove tooltip
                });

            svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${height - margin.bottom})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .style("text-anchor", "end") // set text anchor to end
                .attr("dx", "-.8em") // set horizontal position
                .attr("dy", ".15em") // set vertical position
                .attr("transform", "rotate(-90)"); // rotate text by -90 degrees


            svg.append("g")
                .attr("class", "y-axis")
                .attr("transform", `translate(${margin.left}, 0)`)
                .call(d3.axisLeft(yScale));



        }

        function extractColumnValuesAsLists(filePath, xColumnName, yColumnName, name, release, type) {
            return d3.csv(filePath).then(data => {
                // Ensure both columns exist to avoid errors
                if (data.length > 0 && !(xColumnName in data[0]) && !(yColumnName in data[0])) {
                    throw new Error(`One or both columns "${xColumnName}" and "${yColumnName}" do not exist in the CSV file.`);
                }

                let xList = [];
                let yList = [];
                let nameList = [];
                let releaseList = [];
                let typeList = [];

                data.forEach(row => {
                    const xValue = row[xColumnName];
                    let yValue;
                    if (row[yColumnName].indexOf(',') > -1) {
                        yValue = row[yColumnName].substring(0, row[yColumnName].indexOf(','));
                    }
                    else {
                        yValue = row[yColumnName];
                    }
                    const nameElement = row[name];
                    const releaseElement = row[release];
                    const typeElement = row[type];
                    if (xValue !== undefined && yValue !== undefined && nameElement !== undefined && releaseElement !== undefined && typeElement !== undefined) {
                        if (yValue.includes('Action') || yValue.includes('RPG') || yValue.includes('Strategy') || yValue.includes('Indie') || yValue.includes('Casual')) {
                            xList.push(xValue);
                            yList.push(yValue);
                            nameList.push(nameElement);
                            releaseList.push(new Date(releaseElement)); // Parse release date
                            typeList.push(typeElement);
                        }
                    }
                });

                // xList = shuffleArray(xList);
                // yList = shuffleArray(yList);
                // nameList = shuffleArray(nameList);
                // releaseList = shuffleArray(releaseList);
                // typeList = shuffleArray(typeList);
                // Sort data by release date
                const sortedIndices = releaseList.map((_, i) => i).sort((a, b) => releaseList[a] - releaseList[b]);
                xList = sortedIndices.map(i => xList[i]).slice(0, 15);
                yList = sortedIndices.map(i => yList[i]).slice(0, 15);
                nameList = sortedIndices.map(i => nameList[i]).slice(0, 15);
                releaseList = sortedIndices.map(i => releaseList[i]).slice(0, 15);
                typeList = sortedIndices.map(i => typeList[i]).slice(0, 15);



                return { xList, yList, nameList, releaseList, typeList };
            });
        }

        const dataset_path = "steam_games.csv";

        extractColumnValuesAsLists(dataset_path, 'all_reviews', 'popular_tags', 'name', 'release_date', 'types')
            .then(data_object => {
                console.log(data_object);
                createPlot(data_object);
            })
            .catch(error => {
                console.error(error);
            });


    </script>
</body>

</html>